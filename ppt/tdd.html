<!DOCTYPE html>
<html>
  <head>
    <title>My Awesome Presentation</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Test Driven Development by Example

liu chuanjun 

2017-11-10
---
##什么是tdd
1. a way to make sure that what your code is doing what it should be doing
2. 先编码，再测试
3. TDD的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。TDD虽是敏捷方法的核心实践
---
##传统的编码
1. 写代码
2. 看看对不对
3. NO.，继续修改
4. YES，丢给测试人员，自己继续干别的
---
##TDD
1. 写测试
2. 让测试成功
3. 实现测试需要的编码
4. 测试成功
5. 更多测试
---
##好处
1. 降低编码难度
  - 抛球编码
  - 三个球：功能，重构，性能
  - 节奏感
2. 提升自信
  - 有条不紊
  - 正反馈
  - 自动测试保护下的编码
3. 代码可信
  - 过去看代码的经验
  - 先跑测试
  - 看测试用例
4. 可执行的文档
---
##有人说
1. 每当我需要添加新代码、维护老代码的时候，我就会陷入紧张和恐慌，总觉得新代码会让整个应用瘫痪
2. 如果你有了各种各样的测试，重新跑测试，你就可以放心的去重构代码了
3. 自动测试通过捕捉更多的错误，增强了软件到达用户之前的稳定性。就好比是一张防护网一样，使开发者们在做更改的时候不必担心引发未知的错误。
4. 与直觉相反，维护一个高质量的测试套件能够极大地提高开发人员的效率，因为它使得开发人员能够立即发现开发中的错误。反过来说，如果没有这些套件，终端用户会遇到更多的bug，从而导致需要在用户服务，质量保证和错误报告上面投入更多的资源
---
##来个案例

1. 检查一个字符串是否为整数？
- 希望编写一个isInt的函数，原型为function (str:string)->bool
- 字符串内可以由数字构成。比如"12345"返回true,12a返回false
- 数字可以有负号,但是必须出现在第一位，且最多只能出现一次。比如允许“-12”，不允许“12-”
2. 搭建环境
3. 实际查看编码和自己练习

---
##搭建环境
1. 环境
  - 语言：js .js很流行,语法负担少，不挑电脑
  - 环境：jasmine,不太需要搭建环境
2. jasmine
- 下载 ：https://github.com/jasmine/jasmine/releases 
- 查看jasmine结构，源代码，测试包
- 使用jasmine和js的好处，更多针对不同语言的单元测试工具包
---
## jasmine概览
1. 目录和文件知识点
- src
- spec
- SpecRunner
2. 代码内知识点
- describe - suite
- it - spec
- expect 
- toEqual
- toMatch
- beforeEach
- afterEach
- disable spec or suite

---
##DEMO

- testcase:https://gist.github.com/1000copy/d9ed068db2b069c7ed3986d586f9fef9
- src code : https://gist.github.com/1000copy/fd25640b0106aa074965d1cf69d27679
---
## 感受
1. 传统编码
2. TDD
1. 何为：测试现行？
2. 何为：测试就是文档?
3. 何为：红绿红绿？
4. MF，因为第一次做，有些不适应，慌里慌张的做完
5. 说说好处
---
##细说:测试就是文档
1. 仅仅是看函数名，也可以猜出大概的功能
2. 但是不如测试用例具体，也不如测试用例可以运行验证，
3. 比如并且如果想要知道此函数是否支持科学计数法的话，从测试用例上可以看得出来仅仅看函数名是不够的。
4. 所以说，有文档很好，没有的话，测试用例就可以帮着更好的了解功能。并且这些测试用例是可以运行的，因此更加可靠，不必担心文档更新不及时。
5. 强迫具象化，输入一个个的参数，希望结果正确，帮助你具象函数的执行

---
##创造者
1. kent beck 其人 
- 他在Facebook工作
- 出版过很多书
- 在大型IT公司工作的软件思想家。
- 12岁的时候读书，做计算之前，先确定输入和对应的正确输出，然后在开始实现计算
2. MF其人
- 最难以说清楚的就是tdd会给编码中带来的自信的体验
- 空中抛球的比喻，几个球：功能，测试，重构，未知知识
---
##课后练习1
1. 试试在编写函数前，首先确定输入和输出
2. 编写一个方法，输入double参数，返回字符串
3. 要求对输入保留两位小数，不要四舍五入
---
##课后练习2
- 函数修改为isDigital
- 加入对小数点的判断
- 小数点只能出现一次
- 如果有符号，小数点只能出现在符号后，并且除了符号和小数点，至少得有一位数字
---
##课后练习3
- 编写斐波那契数列fab
- f(0) = 0 ,f(1)=1,f(n) = f(n-1) + f(n-2)
---
##第一课完
---
##第2课开始
---
##再来一个案例
1. 测试先行
2. 但是加入用户界面的编码
3. 体验代码，UI，测试的三个球
4. 一点点的重构
---
## HTML计算器
1. 使用html做UI
2. 看着UI，推演流程
3. 正常流
- 使用结构化编程（全局变量+函数），创建最简单直接的正常程序流的测试
- 1+1=2
- 1.1+2=2.1
4. 异常流
- “1.1++”
- “1.1.1”
- “*1”
- “/1”
- 代码链接到UI
---
##DEMO
---
##尬聊
1. 正常流和异常流
2. 代码链接到UI
3. 重构
- 重构结构化代码到OO
- 分离
- 模块：util，calc
- 分离测试
4. 体会
- 功能、优良代码两个球不要同时在空中
-  实现UI时，只管UI
-  UI代码不做测试先行
-  逻辑代码要做测试现行
-  实现代码后，链接到UI
---
##测试覆盖
![testdirectly](testdirectly.png)
---
##第2课完
---
##第3课开始
---
##依赖拆除
- 单元测试，一次测试一个单元
- 要是要测试的单元依赖另一个单元呢？
- 在测试代码内拆除此依赖
---
##来个案例
- 一个进销存案例
- class order，class warehouse
- 测试warehouse就是单元测试
- 测试order，因为依赖了warehouse就不是单元测试
- 使用mock可以拆除此依赖
- test double 
---
## DEMO
1. 单行订单
2. 传递warehouse实例到order
3. 依赖hasInventory
```javascript
function Order(product,qty){
  this.product = product
  this.qty = qty
  this.warehouse = {}
}
Order.prototype.post = function() {
  // var warehouse = new Warehouse()
  return  this.warehouse.hasInventory(this.product,this.qty) && sendmail()
};
```
---
##知识点
1. 可以mock一个空白实现的对象的函数
- 监视函数，spyOn(obj,'functionName')
- 并提供一个伪实现 and.callFake(function(和实现函数一样的参数表){ 伪实现}}
- 并提供一个返回值 and.returnValue(返回值)
2. 断言其调用情况
- expect(obj.functionName).toHaveBeenCalled()
- expect(obj.functionName).not.toHaveBeenCalled()
- 查看调用参数 obj.calls

---
##总结
1. 开启TDD模式。即便当前模块依赖的类没有编写，也可以暂时mock它，单独测试当前开发的模块
2. 团队可以并行工作。
3. 前后端人员只需要定义好接口文档就可以开始并行工作，互不影响
4. 后端与后端之间如果有接口耦合，也同样能被Mock解决；
5. 可以模拟那些无法访问的资源。比如墙外
---
##更多案例
如果存储使用mongodb，那么在实现存储之前，可以先mock它
使用email的话，可以在实现前mock它
作为饭店系统的服务员和厨师的比喻
---
## 尬聊：更大案例
- todo management 
- 首先使用html+css创建一个大概能用的ui
- 创建specrunner ,引用对象TodoItems.add,TodoItems.loadAll,这两个函数依赖于HTTP对象的POST，GET方法。
- 创建TodoItems，HTTP对象，并且暂时mockHTTP对象的实现。使用spyOn，从而使得尽管HTTP还没有实现，依然可以测试TodoItems对象的实现。
- 使用mock，完全完成客户端开发后，在暂时搁置客户端，开始编写服务器端，以及本来还没有实现的hTTP对象。
- 单独测试HTTP对象
-  链接完成的代码到UI
当todoItems对自己的集合数据做添加和删除时，同时需要使用网络api时（此时api还没有开发），可以使用mock暂时替代api，并且此时也无需server的运行。
- 使用http post，delete.get来做通讯
- node+express.js做一个restful app
---
## 知识点
1. async expect
2. 对异步调用加断言的方法，使用done参数 
---
##可能的坏处
- 工期紧，时间短，写TDD太浪费时间；
- 业务需求变化太快，修改功能都来不及，根本没有时间来写TDD；
- 写TDD对开发人员的素质要求非常高，普通的开发人员不会写；
- TDD 推行的最大问题在于大多数程序员还不会「写测试用例」和「重构」；
- 由于大量使用Mock和Stub技术，导致UT没有办法测试集成后的功能，对于测试业务价值作用不大
---
##如何开始你的tdd之旅
- 反复练习已有的案例
- 尝试函数到类到模块到系统的逐步应用
- 对无法应用的比如UI，接受它，不去勉强
- 对于难以使用expect的，只能答应出来看的，接受它，不去勉强
- 交流你的困难
---
##我的应用
- 商业管理系统 - 少量
- 短信 - 大部
- 光盘流程 - 大部

- 软件狗 - 全部
- cnode - 无
---
    </textarea>
    <script src="out/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
